Family X {
  type R = {n: N}

  Family C {
    type T = T1 {n: N}

    val f: B -> T = lam (x: B). match T(T1 {n = 10}) with <someCases> {}

    cases someCases <T>: {} -> { T1: {n: N} -> X.C.T } = lam (_: {}).
      { T1 = lam (x: {n: N}). T(T1 {n = x.n})
      }
  }
  Family D extends self(X).C {
    type T += T2 {b: B}

    val f: B -> T = lam (x: B). T(T2 {b = true})
    val g: T -> N = lam (t: T). 10

    // Currently fails to unify output types
    // self(self(<>.X).D).T (from this handler) with self(self(<>.X).C).T (from handler in X.C)
    cases someCases <T>: {} -> { T2: {b: B} -> X.C.T } += lam (_: {}).
      { T2 = lam (y: {b: B}). X.C.T(T1 {n = 2})
      }

  }
}

Family Y extends X {
  type R += {b: B = true}

  Family C {
    type T += T3 {t: T} | T4 {t1: T, t2: T}

    val f: B -> T = lam (n: B). T(T3 {t = T(T1 {n = 3})})

    val h: X.D.T -> N = X.D.g    // "Specialization" should typecheck

    cases someCases <T>: {} -> { T3: {t: T} -> X.C.T, T4: {t1: T, t2: T} -> X.C.T } += lam (_: {}).
      { T4 = lam (x: {t1: T, t2: T}). match x.t1 with <someCases> {}
      , T3 = lam (x: {t: T}). match x.t with <someCases> {}
      }
  }
}