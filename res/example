Family X {
  type R = R1 {n: N}

  Family C {
    type T = T1 {n: N}

    val f: B -> N = lam (x: B). match X.T(T1 {n = 10}) with <someCases> {}

    cases someCases <T>: {} -> { T1: {n: N} -> N } = lam (_: {}).
      { T1 = lam (x: {n: N}). x.n }
  }
  Family D extends self(X).C {
    type T += T2 {b: B}

    val f: B -> N = lam (x: B). 42

    cases someCases <T>: {} -> { T2: {b: B} -> N } += lam (_: {}).
      { T2 = lam (y: {b: B}). 10 }
  }
}

Family Y extends X {
  type R += R2 {b: B}

  Family C {
    type T += T3 {t: T} | T4 {t1: T, t2: T}

    val f: B -> N = lam (n: B). 1

    cases someCases <T>: {} -> { T3: {t: T} -> N, T4: {t1: T, t2: T} -> N } += lam (_: {}).
      { T4 = lam (x: {t1: T, t2: T}). 1
      , T3 = lam (x: {t: T}). match x.t with <someCases> {}
      }
  }
}