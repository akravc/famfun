Family A1 {
  Family B1 {
    type Exp = ENat {n : N}
    val f: N -> N = lam (n: N). n
    val eval: Exp -> N = lam (e: Exp). match e with <eval_cases> {}
    cases eval_cases <Exp> : {} -> {ENat: {n: N} -> N} =
      lam (unit: {}). {ENat = lam (x: {n: N}). x.n}
  }
  Family B2 extends self(A1).B1 {
    val f: N -> N = lam (n: N). n+1
  }
}
Family A2 extends A1 {
  Family B1 {
    val f: N -> N = lam (n: N). n+2
  }
  Family B2 extends self(A2).B1 {
    type X = {x: B}
    type Exp += EPlus {e1: Exp, e2: Exp}
    cases eval_cases <Exp> : {} -> {EPlus: {e1: Exp, e2: Exp} -> N} +=
      lam (unit: {}). {EPlus = lam (x: {e1: Exp, e2: Exp}).
        (eval(x.e1) + eval(x.e2))
    }
  }
}
Family ABMain {
  val main1: {} -> N = lam (ignore: {}). A2.B2.eval (A2.B2.Exp(ENat {n = 3}))
  val main2: {} -> N = lam (ignore: {}). A2.B2.f (3)
}

