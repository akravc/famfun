Family STLCBase {
  type Ty = TUnit{} | TNat{} | TArr{t1: Ty, t2: Ty}
  type Val = U{} | Var{x: String} | Lam{x: String, e: Exp}
  type Exp = EVal{v: Val} | EApp{e1: Exp, e2: Exp}

  type OptionVal = None{} | Some{v: Val}
  def bind(f: Val -> self(STLCBase).OptionVal): self(STLCBase).OptionVal -> self(STLCBase).OptionVal =
    case None{} = self(STLCBase).OptionVal(None{});
    case Some{v: Val} = f(v)

  def eval: Exp -> self(STLCBase).OptionVal =
    case EVal{v: Val} = self(STLCBase).OptionVal(Some{v = v});
    case EApp{e1: Exp, e2: Exp} = bind(lam(v: Val).apply(e2,v), eval(e1))

  def apply(e2: Exp): Val -> self(STLCBase).OptionVal =
    case Lam{x: String, e: Exp} = eval (subst(x, e2, e));
    case _ = self(STLCBase).OptionVal(None{})

  def subst(x: String, e0: Exp): Exp -> Exp =
    case EVal{v: Val} = substVal(x, e0, v);
    case EApp{e1: Exp, e2: Exp} = Exp(EApp{e1 = subst(x, e0, e1), e2 = subst(x, e0, e2)})

  def substVal(y: String, e0: Exp): Val -> Exp =
    case U{} = Exp(EVal{v = Val(U{})});
    case Var{x: String} = if x==y then e0 else Exp(EVal{v = Val(Var{x = x})});
    case Lam{x: String, e: Exp} = Exp(EVal{v = if x==y then Val(Lam{x = x, e = e}) else Val(Lam{x = x, e = subst(y, e0, e)})})

  def branch(e1: Exp, e2: Exp): Val -> self(STLCBase).OptionVal =
    case _ = self(STLCBase).OptionVal(None{})
}

Family STLCIf extends STLCBase {
  type Ty += TBool{}
  type Val += True{} | False{}
  type Exp += EIf{e: Exp, e1: Exp, e2: Exp}

  def eval: Exp -> self(STLCIf).OptionVal +=
    case EIf{e: Exp, e1: Exp, e2: Exp} =
      bind(branch(e1, e2), eval(e))

  def branch(e1: Exp, e2: Exp): Val -> self(STLCIf).OptionVal +=
    case True{} = eval e1;
    case False{} = eval e2;
    case _ = self(STLCIf).OptionVal(None{})

  def apply(e2: Exp): Val -> self(STLCIf).OptionVal +=
    case _ = self(STLCIf).OptionVal(None{})

  def subst(x: String, e0: Exp): Exp -> Exp +=
    case EIf{e: Exp, e1: Exp, e2: Exp} = Exp(EIf{e = subst(x, e0, e), e1 = subst(x, e0, e1), e2 = subst(x, e0, e1)})

  def substVal(y: String, e0: Exp): Val -> Exp +=
    case True{} = Exp(EVal{v = Val(True{})});
    case False{} = Exp(EVal{v = Val(False{})})
}

Family BaseComp {
  type ListString = NilString{} | ConsString{head: String, tail: ListString}

  Family STLC extends STLCBase {}

  Family IL {
    type Ty = TUnit{} | TCont{ts: ListTy}
    type Val = U{} | Var{x: String}
    type Exp = ELet{x: String, v: Val, e: Exp} | EApp{v: Val, vs: ListVal} | EHalt{v: Val}
    type Fun = MkFun{n: String, xs: self(BaseComp).ListString, e: Exp}

    type ListTy = NilTy{} | ConsTy{head: self(self(BaseComp).IL).Ty, tail: self(self(BaseComp).IL).ListTy}
    type ListVal = NilVal{} | ConsVal{head: self(self(BaseComp).IL).Val, tail: self(self(BaseComp).IL).ListVal}
    type ListFun = NilFun{} | ConsFun{head: self(self(BaseComp).IL).Fun, tail: self(self(BaseComp).IL).ListFun}

    type OptionVal = None{} | Some{v: self(self(BaseComp).IL).Val}

    val substs: self(BaseComp).ListString -> ListVal -> Exp -> Exp =
      lam(ys: self(BaseComp).ListString). lam(vs: ListVal). lam(e: Exp). e // TODO

    def map(f: self(self(BaseComp).IL).Val -> self(self(BaseComp).IL).Val): self(self(BaseComp).IL).ListVal -> self(self(BaseComp).IL).ListVal =
      case NilVal{} = self(self(BaseComp).IL).ListVal(NilVal{});
      case ConsVal{head: self(self(BaseComp).IL).Val, tail: self(self(BaseComp).IL).ListVal} = self(self(BaseComp).IL).ListVal(ConsVal{head = f(head), tail = map(f, tail)})

    def eval(fs: ListFun): Exp -> self(self(BaseComp).IL).OptionVal =
      case ELet{x: String, v: Val, e: Exp} = eval(fs, subst(x, v, e));
      case EApp{v: Val, vs: ListVal} = apply(fs, vs, v);
      case EHalt{v: Val} = self(self(BaseComp).IL).OptionVal(Some{v = v})

    def apply(fs: ListFun, vs: ListVal): Val -> self(self(BaseComp).IL).OptionVal =
      case _ = self(self(BaseComp).IL).OptionVal(None{})

    def subst(y: String, v0: Val): Exp -> Exp =
      case ELet{x: String, v: Val, e: Exp} =
        if x==y then Exp(ELet{x=x, v=substVal(y, v0, v), e=e}) else Exp(ELet{x=x, v=substVal(y, v0, v), e=subst(y, v0, e)});
      case EApp{v: Val, vs: ListVal} = Exp(EApp{v = substVal(y, v0, v), vs = map(substVal(y, v0), vs)});
      case EHalt{v: Val} = Exp(EHalt{v = substVal(y, v0, v)})

    def substVal(y: String, v0: Val): Val -> self(self(BaseComp).IL).Val =
      case U{} = self(self(BaseComp).IL).Val(U{});
      case Var{x: String} = if x==y then v0 else self(self(BaseComp).IL).Val(Var{x = x})

    // TODO: this should be defined only in ILC
    def unpack(fs: ListFun, alpha: String, x: String, e: Exp): Val -> self(self(BaseComp).IL).OptionVal =
      case _ = self(self(BaseComp).IL).OptionVal(None{})
  }

  Family ILK extends self(BaseComp).IL {
    type Val += Lam{xs: self(BaseComp).ListString, e: self(self(BaseComp).ILK).Exp}

    def apply(fs: ListFun, vs: ListVal): Val -> self(self(BaseComp).ILK).OptionVal +=
      case Lam{xs: self(BaseComp).ListString, e: self(self(BaseComp).ILK).Exp} = eval(fs, substs(xs, vs, e))

    def substVal(y: String, v0: Val): Val -> self(self(BaseComp).ILK).Val +=
      case Lam{xs: self(BaseComp).ListString, e: self(self(BaseComp).ILK).Exp} = self(self(BaseComp).ILK).Val(Lam{xs = xs, e = e}) // TODO

    // TODO: shouldn't be needed here!
    def unpack(fs: ListFun, alpha: String, x: String, e: Exp): Val -> self(self(BaseComp).ILK).OptionVal +=
      case _ = self(self(BaseComp).ILK).OptionVal(None{})
  }

  Family ILC extends self(BaseComp).IL {
    type Ty += TVar{alpha: String} | TExists{alpha: String, ty: Ty}
    type Val += Pack{t: self(self(BaseComp).ILC).Ty, v: self(self(BaseComp).ILC).Val} | Name{n: String}
    type Exp += EUnpack{alpha: String, x: String, v: Val, e: Exp}

    val substTy: String -> Ty -> Exp -> Exp =
      lam(y: String). lam(t: Ty). lam(e: Exp). e // TODO

    def eval(fs: ListFun): Exp -> self(self(BaseComp).ILC).OptionVal +=
      case EUnpack{alpha: String, x: String, v: self(self(BaseComp).ILC).Val, e: self(self(BaseComp).ILC).Exp} = unpack(fs, alpha, x, e)(v)

    def unpack(fs: ListFun, alpha: String, x: String, e: Exp): Val -> self(self(BaseComp).ILC).OptionVal +=
      case Pack{t: self(self(BaseComp).ILC).Ty, v: self(self(BaseComp).ILC).Val} = eval(fs, subst(x, v, substTy(alpha, t, e)));
      case _ = self(self(BaseComp).ILC).OptionVal(None{})

    def subst(y: String, v0: Val): Exp -> Exp +=
      case EUnpack{alpha: String, x: String, v: Val, e: Exp} =
        Exp(EUnpack{alpha = alpha, x = x, v = v, e = if x==y then e else subst(y, v0, e)})

    def substVal(y: String, v0: Val): Val -> self(self(BaseComp).ILC).Val +=
      case Pack{t: self(self(BaseComp).ILC).Ty, v: self(self(BaseComp).ILC).Val} = self(self(BaseComp).ILC).Val(Pack{t = t, v = substVal(y, v0, v)});
      case Name{n: String} = self(self(BaseComp).ILC).Val(Name{n = n})

    def apply(fs: ListFun, vs: ListVal): Val -> self(self(BaseComp).ILC).OptionVal +=
      case Name{n: String} = self(self(BaseComp).ILC).OptionVal(None{}); // TODO
      case Pack{t: self(self(BaseComp).ILC).Ty, v: self(self(BaseComp).ILC).Val} = self(self(BaseComp).ILC).OptionVal(None{})
  }
}